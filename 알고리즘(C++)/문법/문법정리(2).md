# C++ 문법
## ✏️ 메모리/포인터
### ✔️ 포인터
- 컴퓨터 메모리 각 셀의 크기는 1바이트
- `&` 메모리의 주소를 얻는 연산자
- **포인터**: 메모리의 주소를 담는 타입(동적할당, 함수 매개변수, 클래스 및 구조체에 사용)
- `<타입> * 변수명`
- OS가 32bit일때 포인터는 4바이트/64bit일때 8바이트

**`*` 용도**
1. 포인터 타입 선언
2. 역참조
```cpp
int main(){
    string a = "abcda";
    string * b = &a; 
    cout << b << "\n"; //주소출력
    cout << *b << "\n"; //값출력
    return 0;
}
``` 

#### ✨array to pointer decay
- 배열의 이름을 배열의 첫 번째 주소로 사용 가능
- **vector는 불가능/array만 가능**
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3] = {1, 2, 3};
int main(){
    int * c = a;
    cout << c << "\n";   //0x..00
    cout << &a[0] << "\n"; //0x..00
    cout << c + 1 << "\n"; //0x..04(4바이트, int라서)
    cout << &a[1] << "\n"; //0x..04
    return 0;
}
```
> **실제값**<br>           a[1] == *(a+1)<br>
> **주소**<br>             &a[1] == (a+1)

---
### ✔️ 메모리 구조
#### ✨정적할당
**데이터영역(BSS/Data 영역)**
- **BSS영역**: `전역변수, const, static` 변수 중 0으로 초기화 되어 있거나 초기화가 되어있지 않은 변수 
    - ex) const int a = 0;
- **Data영역**: `전역변수, const, static` 변수 중 0이 아닌 값으로 초기화된 변수
  - ex) const int a = 2;

**코드영역**
- 코드가 들어감

#### ✨동적할당
**Stack**
- `지역변수, 매개변수, 함수`
- 컴파일 때 크기가 정해짐
- 함수 호출 등에 따라 런타임 시 크기 변경될 수 있음
- 재귀함수의 지역변수는 독립적으로 작용함/다른 함수에 영향 미치지 않음

**Heap**
- 동적 할당
- 런타임 시 크기 결정됨
- ex. `vector`


---
## ✏️ 이터레이터

- 주소를 가리키는 개체, 포인터를 일반화함
- 주소값을 바로 반환 불가능 -> `&*`사용해야함
```cpp
int main(){
    for(int i = 1; i <= 5; i++)v.push_back(i);
    for(int i = 0; i < 5; i++){
        cout << *(v.begin() + i) << "\n"; //실제값
        cout << &*(v.begin() + i) << '\n'; //주소(4씩 증가)
    }
 // cout << v.begin() << '\n'; //에러

    for(auto it = v.begin(); it != v.end(); it++){
        cout << *it << ' ';
    }

    for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
        cout << *it << ' ';
    }

    auto it = v.begin(); //1
    advance(it, 3);      
    cout << *it << '\n'; //4
   
}
```

#### ✨advance(iterator, cnt)
- 이터레이터를 cnt만큼 증가시킴
- ex. iterator = v.begin() + 1/cnt = 3 -> v.begin() + 4까지 증가


---
## ✏️ 함수
### ✔️ 입력
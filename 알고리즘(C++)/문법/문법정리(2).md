# C++ 문법
## ✏️ 메모리/포인터
### ✔️ 포인터
- 컴퓨터 메모리 각 셀의 크기는 1바이트
- `&` 메모리의 주소를 얻는 연산자
- **포인터**: 메모리의 주소를 담는 타입(동적할당, 함수 매개변수, 클래스 및 구조체에 사용)
- `<타입> * 변수명`
- OS가 32bit일때 포인터는 4바이트/64bit일때 8바이트

**`*` 용도**
1. 포인터 타입 선언
2. 역참조
```cpp
int main(){
    string a = "abcda";
    string * b = &a; 
    cout << b << "\n"; //주소출력
    cout << *b << "\n"; //값출력
    return 0;
}
``` 

#### ✨array to pointer decay
- 배열의 이름을 배열의 첫 번째 주소로 사용 가능
- **vector는 불가능/array만 가능**
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3] = {1, 2, 3};
int main(){
    int * c = a;
    cout << c << "\n";   //0x..00
    cout << &a[0] << "\n"; //0x..00
    cout << c + 1 << "\n"; //0x..04(4바이트, int라서)
    cout << &a[1] << "\n"; //0x..04
    return 0;
}
```
> **실제값**<br>           a[1] == *(a+1)<br>
> **주소**<br>             &a[1] == (a+1)

---
### ✔️ 메모리 구조
#### ✨정적할당
**데이터영역(BSS/Data 영역)**
- **BSS영역**: `전역변수, const, static` 변수 중 0으로 초기화 되어 있거나 초기화가 되어있지 않은 변수 
    - ex) const int a = 0;
- **Data영역**: `전역변수, const, static` 변수 중 0이 아닌 값으로 초기화된 변수
  - ex) const int a = 2;

**코드영역**
- 코드가 들어감

#### ✨동적할당
**Stack**
- `지역변수, 매개변수, 함수`
- 컴파일 때 크기가 정해짐
- 함수 호출 등에 따라 런타임 시 크기 변경될 수 있음
- 재귀함수의 지역변수는 독립적으로 작용함/다른 함수에 영향 미치지 않음

**Heap**
- 동적 할당
- 런타임 시 크기 결정됨
- ex. `vector`


---
## ✏️ 이터레이터

- 주소를 가리키는 개체, 포인터를 일반화함
- 주소값을 바로 반환 불가능 -> `&*`사용해야함
```cpp
int main(){
    for(int i = 1; i <= 5; i++)v.push_back(i);
    for(int i = 0; i < 5; i++){
        cout << *(v.begin() + i) << "\n"; //실제값
        cout << &*(v.begin() + i) << '\n'; //주소(4씩 증가)
    }
 // cout << v.begin() << '\n'; //에러

    for(auto it = v.begin(); it != v.end(); it++){
        cout << *it << ' ';
    }

    for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
        cout << *it << ' ';
    }

    auto it = v.begin(); //1
    advance(it, 3);      
    cout << *it << '\n'; //4
   
}
```

#### ✨advance(iterator, cnt)
- 이터레이터를 cnt만큼 증가시킴
- ex. iterator = v.begin() + 1/cnt = 3 -> v.begin() + 4까지 증가


---
## ✏️ 함수
### ✔️ `fill()`, `memset()`

#### ✨ `fill()`/ `O(n)`
- 모든 값으로 초기화 가능
- `[first,last)`

`void fill(ForwardIterator first, ForwardIterator last, const T& val)`

```cpp
int a[10];
int b[10][10];

fill(&a[0], &a[10], 100);
fill(&b[0][0], &b[9][10], 2);

fill(a,a + 10, 100);
fill(&b[0][0], &b[0][0] + 10 * 10, 2);
```
> - 1차원의 경우 a, a + 10, 즉, 배열의 이름 + 숫자로 가능<br>
>- 2차원 이상일 경우에는 반드시 &b[0][0] + 숫자로 해야함

<br>
<br>

**부분 초기화보다 전체초기화 많이 사용하기**
- 열별로 순차적으로 초기화가 일어나기 때문

ex) 8 * 8 정사각형으로 초기화하려고 할때
```cpp
int a[10][10];
int main(){
    fill(&a[0][0], &a[0][0] + 8 * 8 , 4);
    for(int i = 0; i < 10; i++){
        for(int j = 0; j < 10; j++){
            cout << a[i][j] << " ";
        }
        cout << '\n';
    }
    return 0;
}
/*  64개
4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4
4 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
*/
```

---
#### ✨ `memset()`

- 0, -1로 초기화하는 경우 fill보다 memset이 더 빠름
- 바이트단위로 초기화를 하며 0, -1, char형의 하나의 문자(a, b, c..)로 초기화
- memset(배열의 이름, k, 배열의 크기)

`void * memset ( void * ptr, int value, size_t num );`

```cpp
int a[1004];
int a2[1004][1004];

memset(a, -1, sizeof(a));
memset(a2, 0, sizeof(a2));
```
---
#### ✨ 쓰지 말아야 할 초기화 방법 {0, }
- T myarray[N] = {0, };
- ex. int a[5] = {0,};
- 이 방법은 초반에 한번하는 정적초기화로써만 유효
- 동적초기화로써는 동작하지 않음

---

### ✔️ `memecpy()`, `copy()`
- 둘 다 깊은 복사

**얕은 복사와 깊은 복사**
- 얕은 복사(Shallow copy)는 메모리 주소값을 복사한 것이라 복사한 배열을 수정하면 원본 배열이
수정되는 복사방법
-  깊은 복사(Deep copy)는 새로운 메모리 공간을 확보해 완전히 복사해 복사한 배열을 수정하면 원본 배열은 수정되는 않는 복사방법


#### ✨ `memecpy()`
- `Array`를 깊은 복사할 때 사용

`void * memcpy ( void * destination, const void * source, size_t num );`

```cpp
int v[3] = {1, 2, 3};
int ret[3];
memcpy(ret, v, sizeof(v));
```

- memcpy()는 vector에서는 깊은 복사가 되지 않음
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(void) {
    vector<int> v {1, 2, 3};
    vector<int> ret(3);
    memcpy(&ret, &v, 3*sizeof(int));
    cout << ret[1] << "\n"; //2
    ret[1] = 100;
    cout << ret[1] << "\n"; //100
    cout << v[1] << "\n"; //100
    return 0;
}
```
- ret[1]을 수정했더니 v[1]도 수정됨
- memcpy()는 `TriviallyCopyable`인 타입이 아닌 경우 함수가 오동작

---
#### ✨ `copy()`
- vector와 Array 모두 사용가능

`copy (InputIterator first, InputIterator last, OutputIterator result)`

v : 복사당하는 vector / ret : 복사하는 vector
`copy(v.begin(), v.end(), ret.begin());`

```cpp
vector<int> v {1, 2, 3};
vector<int> ret(3);
copy(v.begin(), v.end(), ret.begin());
```
- 복사하는 vector와 복사당하는 vector의 크기를 맞춰주는 것이 중요

```cpp
int v[3] = {1, 2, 3};
int ret[3];
copy(v, v + n, ret);
```
---
